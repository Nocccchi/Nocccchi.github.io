[{"title":"Hello World","url":"/2021/11/28/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Vue前端模板整理","url":"/2021/11/28/hello-world%20-%20%E5%89%AF%E6%9C%AC/","content":"模块划分\n目录结构├── build                      // 构建相关  里面是一些脚本文件，用来构建的时候调用，完成相应操作，这些脚本调用的是nodejs提供的api。nodejs是一个js语言的运行环境，类比一下就是jvm相对于java的关系。dist  打包生成的东西mock Mock 数据是前端开发过程中必不可少的一环，是分离前后端开发的关键链路。通过预先跟服务器端约定好的接口，模拟请求数据甚至逻辑，能够让前端开发更加独立自主，不会被服务端的开发所阻塞。node_modules npm install 安装的本项目所需的依赖包 plop-templates 一个自动生成模板代码的小工具├── public                     // 公共文件│   ├── favicon.ico            // favicon图标│   └── index.html             // html模板-----------这个！和底下的俩tinymce  富文本编辑器？├── src                        // 源代码│   ├── api                    // 所有请求│   ├── assets                 // 主题 字体等静态资源│   ├── components             // 全局公用组件│   ├── directive              // 全局指令  自定义的vue指令│   ├── filtres                // 全局 filter│   ├── icons                  // 项目所有 svg icons│   ├── lang                   // 国际化 language│   ├── layout                 // 布局│   ├── router                 // 路由│   ├── store                  // 全局 store管理│   ├── styles                 // 全局样式│   ├── utils                  // 全局公用方法│   ├── vendor                 // 公用vendor  第三方模板│   ├── views                   // view│   ├── App.vue                // 入口页面│   ├── main.js                // 入口 加载组件 初始化等新建一个vue项目，一般一个初步的Vue项目创建好之后都会有这三个文件：index.html 、main.js 、App.js;Vue是单页面形式开发，而这个index.html文件在其中起着特别重要的作用。所有组件（后缀名为.vue都被视为组件）都会通过此文件进行渲染加载。main.js : 这个文件，在我看来，它相当于一个C/Java中的入口函数。控制着初次启动Vue项目要加载的组件。下面是main.js的代码截图，我会对每行代码进行逐一分析import  A   from  ‘B’   这类语句相当于引入B（这一般是路径）然后给它起个名字叫做A；Vue.user(C)这个意思是 全局方法定义 C。也就是说，定义以后，你可以在这个Vue项目的任意地方使用该组件（当然，你不能乱写）。el: &#x27;#app&#x27;和html文件里的app相对应，模板将会替换挂载的元素。-----------------------------------？？？App.vue：组件。额，暂且，你可以把它认为是一个根组件。export中的name属性，相当于给这个组件定义一个名字。便于识别和使用。created: 这是一个生命周期函数，因为App这个组件中并没有任何信息。他只是作为根组件来使用。所以，我们要在进入这个组件的时候跳转到一个初始化界面--login。（个人感觉App没啥用，index.html和main.js完全可以实现这些功能）。   下面，我们来总结一下，vue项目的启动，在表层可视为main.js--&gt;App.vue（组件）--&gt;index.html│   └── permission.js          // 权限管理│   └── settings.js            // 系统配置├── .editorconfig              // 编码格式├── .env.development           // 开发环境配置├── .env.production            // 生产环境配置├── .env.staging               // 测试环境配置├── .eslintignore              // 忽略语法检查├── .eslintrc.js               // eslint 配置项├── .gitignore                 // git 忽略项├── babel.config.js            // babel.config.js  babel  简单来说把 JavaScript 中 es2015/2016/2017/2046 的新语法转化为 es5，让低端运行环境(如浏览器和 node )能够认识并执行。├── package.json               // package.json└── vue.config.js              // vue.config.js\n状态共享Vuex我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：多个视图依赖于同一状态。来自不同视图的行为需要变更同一状态。对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！\nstatemutationsactions👆modulesgetters\n\nstate 存放状态，我们想要共享的东西、值mutations state成员操作，针对stare的操作定义，是操作state数据的方法的集合，比如对该数据的修改、增加、删除等等。\n\ngetters 加工\n可以对state中的成员加工后传递给外界Getters中的方法有两个默认参数state 当前VueX对象中的状态对象getters 当前getters对象，用于将getters下的其他getter拿来用\nstate成员给外界\nactions 异步操作由于直接在mutation方法中进行异步操作，将会引起数据失效（https://segmentfault.com/q/1010000014733271）。所以提供了Actions来专门进行异步操作，最终提交mutation方法。Actions中的方法有两个默认参数context 上下文(相当于箭头函数中的this)对象payload 挂载参数\nmodules 模块化状态管理\n\n我们所要做到的是：不同的权限对应着不同的路由，同时侧边栏也需根据不同的权限，异步生成。这里先简单说一下，我实现登录和权限验证的思路。\n\n登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个token，拿到token之后（我会将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态），前端会根据token再去拉取一个 user_info 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。\n权限验证：通过token获取用户对应的 role，动态根据用户的 role 算出其对应有权限的路由，通过 router.addRoutes 动态挂载这些路由。\n\n上述所有的数据和操作都是通过vuex全局管理控制的。(补充说明：刷新页面后 vuex的内容也会丢失，所以需要重复上述的那些操作)接下来，我们一起手摸手一步一步实现这个系统。\n登录流程\n登录验证拿token当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个token，我会将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态\n\n登录页面（login.vue），点击登录按钮\n handleLogin() &#123;      this.$refs.loginForm.validate(valid =&gt; &#123;        if (valid) &#123;          this.loading = true          this.$store            .dispatch(&#x27;user/login&#x27;, this.loginForm)  //提交表单            .then(() =&gt; &#123;              this.$router.push(&#123;                path: this.redirect || &#x27;/&#x27;,    //跳转首页                query: this.otherQuery              &#125;)              this.loading = false            &#125;)            .catch(() =&gt; &#123;              this.loading = false            &#125;)        &#125; else &#123;          console.log(&#x27;error submit!!&#x27;)          return false        &#125;      &#125;)    &#125;\n表单提交，走登录方法（/store/user.js）\n\n登录成功后，服务端会返回一个 token（该token的是一个能唯一标示用户身份的一个key），之后我们将token存储在本地cookie之中，这样下次打开页面或者刷新页面的时候能记住用户的登录状态，不用再去登录页面重新登录了。\n\n\n  Login(&#123; commit &#125;, userInfo) &#123;      const username = userInfo.username.trim()      const password = userInfo.rsaPass      const code = userInfo.code      const uuid = userInfo.uuid      return new Promise((resolve, reject) =&gt; &#123;        login(username, password, code, uuid).then(res =&gt; &#123;   //后端返回token          localStorage.setItem(&#x27;id&#x27;, res.user_id)          setToken(res.access_token)    //调用@/utils/auth中方法存储token          setRefreshToken(res.refresh_token)    // 刷新token          commit(&#x27;SET_TOKEN&#x27;, res.access_token)          resolve()        &#125;).catch(error =&gt; &#123;          reject(error)        &#125;)      &#125;)    &#125;\n\n存储token(@/utils/auth)\n\nexport function getToken() &#123;  return Cookies.get(TokenKey)&#125;export function setToken(token) &#123;  return Cookies.set(TokenKey, token)&#125;\n拿到token之后（我会将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态），前端会根据token再去拉取一个 user_info 的接口来获取用户的详细信息（如用户权限，用户名等等信息）\n获取用户信息用户登录成功之后，我们会在全局钩子router.beforeEach中拦截路由，判断是否已获得token，在获得token之后我们就要去获取用户的基本信息了（permission.js）\nif (hasToken) &#123;     //判断是否获取到token    if (to.path === &#x27;/login&#x27;) &#123;      // if is logged in, redirect to the home page      next(&#123; path: &#x27;/&#x27; &#125;)      NProgress.done() // hack: https://github.com/PanJiaChen/vue-element-admin/pull/2939    &#125; else &#123;      if (store.getters.roles.length === 0) &#123;        // 判断当前用户是否已拉取完user_info信息        store.dispatch(&#x27;GetInfo&#x27;).then(res =&gt; &#123;          // 拉取user_info          const roles = res.roles          store.dispatch(&#x27;GenerateRoutes&#x27;, &#123; roles &#125;).then(accessRoutes =&gt; &#123;            // 测试 默认静态页面            // store.dispatch(&#x27;permission/generateRoutes&#x27;, &#123; roles &#125;).then(accessRoutes =&gt; &#123;            // 根据roles权限生成可访问的路由表            router.addRoutes(accessRoutes) // 动态添加可访问路由表            // console.log(accessRoutes)            next(&#123; ...to, replace: true &#125;) // hack方法 确保addRoutes已完成            // console.log(&#x27;==============init menu finish=========&#x27;)          &#125;)        &#125;)\n就如前面所说的，我只在本地存储了一个用户的token，并没有存储别的用户信息（如用户权限，用户名，用户头像等）。有些人会问为什么不把一些其它的用户信息也存一下？主要出于如下的考虑：假设我把用户权限和用户名也存在了本地，但我这时候用另一台电脑登录修改了自己的用户名，之后再用这台存有之前用户信息的电脑登录，它默认会去读取本地 cookie 中的名字，并不会去拉去新的用户信息。所以现在的策略是：页面会先从 cookie 中查看是否存有 token，没有，就走一遍上一部分的流程重新登录，如果有token,就会把这个 token 返给后端去拉取user_info，保证用户信息是最新的。 当然如果是做了单点登录得功能的话，用户信息存储在本地也是可以的。当你一台电脑登录时，另一台会被提下线，所以总会重新登录获取最新的内容。而且从代码层面我建议还是把 login和get_user_info两件事分开比较好，在这个后端全面微服务的年代，后端同学也想写优雅的代码\n前端权限\n前端来控制页面级的权限，不同权限的用户显示不同的侧边栏和限制其所能进入的页面(也做了少许按钮级别的权限控制)，后端则会验证每一个涉及请求的操作，验证其是否有该操作的权限，每一个后台的请求不管是 get 还是 post 都会让前端在请求 header里面携带用户的 token，后端会根据该 token 来验证用户是否有权限执行该操作。若没有权限则抛出一个对应的状态码，前端检测到该状态码，做出相对应的操作。\n权限控制的主体思路，前端会有一份路由表，它表示了每一个路由可访问的权限。当用户登录之后，通过 token 获取用户的 role（getinfo）动态根据用户的 role 算出其对应有权限的路由（getRouters）再通过router.addRoutes动态挂载路由。这些控制都只是页面级的\n具体实现\n创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页面。\n当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。\n调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。\n使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。\n\n@/router/index.js\n//所有权限通用路由表//如首页和登录页和一些不用权限的公用页面（@/permission.js）\nrouter.beforeEach(async(to, from, next) =&gt; &#123;  // start progress bar  NProgress.start()  // set page title  document.title = getPageTitle(to.meta.title)  // determine whether the user has logged in  const hasToken = getToken()  if (hasToken) &#123;    if (to.path === &#x27;/login&#x27;) &#123;      // if is logged in, redirect to the home page      next(&#123; path: &#x27;/&#x27; &#125;)      NProgress.done()     &#125; else &#123;      if (store.getters.roles.length === 0) &#123;        // 判断当前用户是否已拉取完user_info信息        store.dispatch(&#x27;GetInfo&#x27;).then(res =&gt; &#123;          // 拉取user_info          const roles = res.roles          store.dispatch(&#x27;GenerateRoutes&#x27;, &#123; roles &#125;).then(accessRoutes =&gt; &#123;                                                                         // 根据roles权限生成可访问的路由表            router.addRoutes(accessRoutes)                   // 动态添加可访问路由表            next(&#123; ...to, replace: true &#125;) // hack方法 确保addRoutes已完成            // console.log(&#x27;==============init menu finish=========&#x27;)          &#125;)        &#125;)          .catch(err =&gt; &#123;            store.dispatch(&#x27;FedLogOut&#x27;).then(() =&gt; &#123;              Message.error(err)              next(&#123; path: &#x27;/&#x27; &#125;)            &#125;)          &#125;)      &#125; else &#123;        next()      &#125;    &#125;  &#125; else &#123;    /* has no token*/    console.log(to.path)    if (whiteList.indexOf(to.path) !== -1) &#123;// 免登录白名单      next()    &#125; else &#123;      next(`/login`)      NProgress.done()    &#125;  &#125;&#125;)\n@/store/modules/permission.js通过用户的权限和之前在router.js里面asyncRouterMap的每一个页面所需要的权限做匹配，最后返回一个该用户能够访问路由有哪些。\nconst permission = &#123;  state: &#123;    routes: [],    addRoutes: []  &#125;,  mutations: &#123;    SET_ROUTES: (state, routes) =&gt; &#123;      state.addRoutes = routes      state.routes = constantRoutes.concat(routes)    &#125;  &#125;,  actions: &#123;    // 生成路由    GenerateRoutes(&#123; commit &#125;) &#123;      return new Promise(resolve =&gt; &#123;        // 向后端请求路由数据        getRouters().then(res =&gt; &#123;          const accessedRoutes = filterAsyncRouter(res.data)          accessedRoutes.push(&#123; path: &#x27;*&#x27;, redirect: &#x27;/404&#x27;, hidden: true &#125;)          commit(&#x27;SET_ROUTES&#x27;, accessedRoutes)          resolve(accessedRoutes)        &#125;)      &#125;)    &#125;  &#125;&#125;// 遍历后台传来的路由字符串，转换为组件对象function filterAsyncRouter(asyncRouterMap) &#123;  return asyncRouterMap.filter(route =&gt; &#123;    if (route.path === &#x27;/&#x27;) &#123;      route.redirect = &#x27;home&#x27;    &#125;    if (route.component) &#123;      // Layout组件特殊处理      if (route.component === &#x27;Layout&#x27;) &#123;        route.component = Layout      &#125; else &#123;        route.component = loadView(route.component)      &#125;    &#125;    if (route.children != null &amp;&amp; route.children &amp;&amp; route.children.length) &#123;      route.children = filterAsyncRouter(route.children)    &#125;    return true  &#125;)&#125;export const loadView = (view) =&gt; &#123; // 路由懒加载  return (resolve) =&gt; require([`@/views/$&#123;view&#125;`], resolve)&#125;export default permission\n\n\n路由流程\nVue Router\n\n单页应用/多页应用多页：每一次页面跳转的时候，后台服务器都会给返回一个新的html文档，这种类型的网站也就是多页网站，也叫做多页应用。ttp://xxx/page2.html单页：第一次进入页面的时候会请求一个html文件，刷新清除一下。切换到其他组件，此时路径也相应变化，但是并没有新的html文件请求，页面内容也变化了。原理是：JS会感知到url的变化，通过这一点，可以用js动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这个时候的路由不是后端来做了，而是前端来做，判断页面到底是显示哪个组件，清除不需要的，显示需要的组件。这种过程就是单页应用，每次跳转的时候不需要再请求html文件了。\n\n多页面的时候，写页面之间的跳转就是a标签，但是Vue做的都是单页应用，标签是不起作用的，你必须使用vue-router来进行管理。路由模块的本质 就是建立起url和页面之间的映射关系。\n资料什么是nodejshttps://www.jianshu.com/p/6062ee5354be\nnpm 是干什么的https://zhuanlan.zhihu.com/p/24357770\nvue项目启动过程https://blog.csdn.net/cxf8881/article/details/80620545\nvuex官方文档https://vuex.vuejs.org/zh/\nvuex的使用https://www.jianshu.com/p/2e5973fe1223\nvue Router官方文档https://router.vuejs.org/zh/\nvue router入门https://www.jianshu.com/p/4c5c99abb864\n"}]